<!DOCTYPE html>
<html>
<head>
  <meta charset='utf-8'>
  <meta name='viewport' content='width=device-width, initial-scale=1.0'>
  <base href="$FLUTTER_BASE_HREF">
  <title>Proposal & SOW Builder v2</title>
  <!-- App Configuration - Load before Flutter app -->
  <script src="config.js"></script>

  <script>
    async function __ensurePdfJsLoaded() {
      try {
        if (window.__pdfjs && window.__pdfjs.getDocument) return window.__pdfjs;
        const mod = await import('./pdfjs/pdf.min.mjs');
        try {
          mod.GlobalWorkerOptions.workerSrc = './pdfjs/pdf.worker.min.mjs';
        } catch (_) {}
        window.__pdfjs = mod;
        return mod;
      } catch (e) {
        try { console.error('[pdfjs] failed to load module', e); } catch (_) {}
        throw e;
      }
    }

    const pdfAnnot = {
      tool: null,
      signatureDataUrl: null,
      strokeColor: '#111111',
      strokeWidth: 2.0,
      _strokesByPage: {},
      _undoneStrokesByPage: {},
      _history: [],
      _undoneHistory: [],
      _nextAnnotId: 1,
      _redrawCallbacks: [],

      setTool(t) {
        this.tool = t;
        try {
          window.dispatchEvent(new CustomEvent('pdf_annot_tool_changed', { detail: { tool: t } }));
        } catch (_) {}
      },
      setSignatureDataUrl(u) {
        this.signatureDataUrl = u;
        try {
          const v = (u || '').toString();
          if (v.trim()) localStorage.setItem('pdfAnnot.savedSignatureDataUrl', v);
        } catch (_) {}
      },
      getSavedSignatureDataUrl() {
        try {
          return localStorage.getItem('pdfAnnot.savedSignatureDataUrl');
        } catch (_) {
          return null;
        }
      },
      _pushHistory(action) {
        try {
          if (!action) return;
          if (!this._history) this._history = [];
          if (!this._undoneHistory) this._undoneHistory = [];
          this._history.push(action);
          this._undoneHistory = [];
          this._requestRedraw();
        } catch (_) {}
      },
      canUndoGlobal() {
        try { return (this._history || []).length > 0; } catch (_) { return false; }
      },
      canRedoGlobal() {
        try { return (this._undoneHistory || []).length > 0; } catch (_) { return false; }
      },
      _findAnnotNodeById(containerId, annotId) {
        try {
          const el = document.getElementById(containerId);
          if (!el) return null;
          return el.querySelector('[data-annot-id="' + String(annotId) + '"]');
        } catch (_) {
          return null;
        }
      },
      undoGlobal(containerId) {
        try {
          const hist = this._history || [];
          if (!hist.length) return false;
          const a = hist.pop();
          if (!this._undoneHistory) this._undoneHistory = [];

          if (a.type === 'draw_add') {
            const key = String(a.page || 1);
            const strokes = this._strokesByPage[key] || [];
            const idx = strokes.lastIndexOf(a.stroke);
            if (idx >= 0) strokes.splice(idx, 1);
            this._undoneHistory.push(a);
            this._requestRedraw();
            return true;
          }

          if (a.type === 'node_create') {
            const n = this._findAnnotNodeById(containerId, a.id);
            if (n && n.parentNode) n.parentNode.removeChild(n);
            this._undoneHistory.push(a);
            this._requestRedraw();
            return true;
          }

          if (a.type === 'node_transform') {
            const n = this._findAnnotNodeById(containerId, a.id);
            if (!n) return false;
            const b = a.before || {};
            if (b.left != null) n.style.left = String(b.left) + 'px';
            if (b.top != null) n.style.top = String(b.top) + 'px';
            if (b.width != null) n.style.width = String(b.width) + 'px';
            if (b.height != null) n.style.height = String(b.height) + 'px';
            if (b.x != null) n.setAttribute('data-x', String(b.x));
            if (b.y != null) n.setAttribute('data-y', String(b.y));
            if (b.w != null) n.setAttribute('data-w', String(b.w));
            if (b.h != null) n.setAttribute('data-h', String(b.h));
            this._undoneHistory.push(a);
            this._requestRedraw();
            return true;
          }

          // Unknown action: push back to preserve ordering.
          hist.push(a);
          return false;
        } catch (_) {
          return false;
        }
      },
      redoGlobal(containerId) {
        try {
          const undone = this._undoneHistory || [];
          if (!undone.length) return false;
          const a = undone.pop();
          if (!this._history) this._history = [];

          if (a.type === 'draw_add') {
            const key = String(a.page || 1);
            if (!this._strokesByPage[key]) this._strokesByPage[key] = [];
            this._strokesByPage[key].push(a.stroke);
            this._history.push(a);
            this._requestRedraw();
            return true;
          }

          if (a.type === 'node_create') {
            const el = document.getElementById(containerId);
            if (!el) return false;
            let targetOverlay = null;
            try {
              const wrappers = el.querySelectorAll('div[data-page]');
              for (let i = 0; i < wrappers.length; i++) {
                const w = wrappers[i];
                const p = parseInt(w.getAttribute('data-page') || '0', 10);
                if (p === (a.page || 1)) {
                  targetOverlay = w.lastElementChild;
                  break;
                }
              }
            } catch (_) {}
            if (!targetOverlay) targetOverlay = el.querySelector('div');
            if (!targetOverlay) return false;
            const html = a.html || '';
            const tmp = document.createElement('div');
            tmp.innerHTML = html;
            const node = tmp.firstElementChild;
            if (!node) return false;
            targetOverlay.appendChild(node);
            try {
              if (typeof window.__pdfAnnotAttachNodeBehaviors === 'function') {
                window.__pdfAnnotAttachNodeBehaviors(node);
              }
            } catch (_) {}
            this._history.push(a);
            this._requestRedraw();
            return true;
          }

          if (a.type === 'node_transform') {
            const n = this._findAnnotNodeById(containerId, a.id);
            if (!n) return false;
            const b = a.after || {};
            if (b.left != null) n.style.left = String(b.left) + 'px';
            if (b.top != null) n.style.top = String(b.top) + 'px';
            if (b.width != null) n.style.width = String(b.width) + 'px';
            if (b.height != null) n.style.height = String(b.height) + 'px';
            if (b.x != null) n.setAttribute('data-x', String(b.x));
            if (b.y != null) n.setAttribute('data-y', String(b.y));
            if (b.w != null) n.setAttribute('data-w', String(b.w));
            if (b.h != null) n.setAttribute('data-h', String(b.h));
            this._history.push(a);
            this._requestRedraw();
            return true;
          }

          undone.push(a);
          return false;
        } catch (_) {
          return false;
        }
      },
      setStrokeWidth(w) {
        try {
          const v = Number(w);
          if (!Number.isFinite(v)) return;

          this.strokeWidth = Math.max(0.5, Math.min(12.0, v));
        } catch (_) {}
      },
      onRedraw(cb) {
        try {
          if (typeof cb !== 'function') return;
          this._redrawCallbacks.push(cb);
        } catch (_) {}
      },
      _requestRedraw() {
        try {
          (this._redrawCallbacks || []).forEach((cb) => {
            try { cb(); } catch (_) {}
          });
          try {
            window.dispatchEvent(new CustomEvent('pdf_annot_changed', { detail: {} }));
          } catch (_) {}
        } catch (_) {}
      },

      canUndo(page) {
        try {
          const key = String(page || 1);
          const arr = this._strokesByPage[key] || [];
          return arr.length > 0;
        } catch (_) {
          return false;
        }
      },
      canRedo(page) {
        try {
          const key = String(page || 1);
          const arr = this._undoneStrokesByPage[key] || [];
          return arr.length > 0;
        } catch (_) {
          return false;
        }
      },
      undo(page) {
        try {
          const key = String(page || 1);
          const strokes = this._strokesByPage[key] || [];
          if (!strokes.length) return false;
          const s = strokes.pop();
          if (!this._undoneStrokesByPage[key]) this._undoneStrokesByPage[key] = [];
          this._undoneStrokesByPage[key].push(s);
          this._requestRedraw();
          return true;
        } catch (_) {
          return false;
        }
      },
      redo(page) {
        try {
          const key = String(page || 1);
          const undone = this._undoneStrokesByPage[key] || [];
          if (!undone.length) return false;
          const s = undone.pop();
          if (!this._strokesByPage[key]) this._strokesByPage[key] = [];
          this._strokesByPage[key].push(s);
          this._requestRedraw();
          return true;
        } catch (_) {
          return false;
        }
      },

      export(containerId) {
        const el = document.getElementById(containerId);
        if (!el) return [];
        const items = [];

        const nodes = el.querySelectorAll('[data-annot-item="1"]');
        nodes.forEach((n) => {
          const type = n.getAttribute('data-annot-type') || '';
          const page = parseInt(n.getAttribute('data-page') || '1', 10);
          const x = parseFloat(n.getAttribute('data-x') || '0');
          const y = parseFloat(n.getAttribute('data-y') || '0');
          const w = parseFloat(n.getAttribute('data-w') || '0');
          const h = parseFloat(n.getAttribute('data-h') || '0');
          if (type === 'text') {
            items.push({ type, page, x, y, w, h, text: n.innerText || '' });
          } else if (type === 'signature') {
            const src = n.getAttribute('data-src') || '';
            items.push({ type, page, x, y, w, h, src });
          }
        });

        try {
          const strokesByPage = pdfAnnot._strokesByPage || {};
          Object.keys(strokesByPage).forEach((k) => {
            const page = parseInt(k, 10);
            const strokes = strokesByPage[k] || [];
            if (strokes && strokes.length) {
              items.push({ type: 'draw', page, strokes });
            }
          });
        } catch (_) {}
        return items;
      },

      import(containerId, items) {
        try {
          const el = document.getElementById(containerId);
          if (!el) return false;
          const arr = Array.isArray(items) ? items : [];

          try {
            const nodes = el.querySelectorAll('[data-annot-item="1"]');
            nodes.forEach((n) => {
              try {
                if (n && n.parentNode) n.parentNode.removeChild(n);
              } catch (_) {}
            });
          } catch (_) {}

          try {
            this._strokesByPage = {};
            this._undoneStrokesByPage = {};
            this._history = [];
            this._undoneHistory = [];
          } catch (_) {}

          const overlaysByPage = {};
          try {
            const wrappers = el.querySelectorAll('div[data-page]');
            for (let i = 0; i < wrappers.length; i++) {
              const w = wrappers[i];
              const p = parseInt(w.getAttribute('data-page') || '0', 10);
              if (!p) continue;
              overlaysByPage[String(p)] = { wrapper: w, overlay: w.lastElementChild };
            }
          } catch (_) {}

          const addNodeCommon = (node, wrapper, overlay, page, x, y, wNorm, hNorm) => {
            try {
              node.style.position = 'absolute';
              const wPx = Math.max(1, wrapper.clientWidth || 1);
              const hPx = Math.max(1, wrapper.clientHeight || 1);
              node.style.left = String(Math.round(x * wPx)) + 'px';
              node.style.top = String(Math.round(y * hPx)) + 'px';
            } catch (_) {}
            try {
              node.setAttribute('data-annot-item', '1');
              node.setAttribute('data-page', String(page));
              node.setAttribute('data-x', String(x));
              node.setAttribute('data-y', String(y));
              node.setAttribute('data-w', String(wNorm));
              node.setAttribute('data-h', String(hNorm));
            } catch (_) {}
            try {
              const annotId = String(pdfAnnot._nextAnnotId++);
              node.setAttribute('data-annot-id', annotId);
              try { pdfAnnot._pushHistory({ type: 'node_create', id: annotId, page, html: node.outerHTML }); } catch (_) {}
            } catch (_) {}
            try {
              overlay.appendChild(node);
              makeDraggable(node, wrapper, overlay);
              makeResizable(node, wrapper);
              makeCornerResize(node, wrapper);
            } catch (_) {}
            try {
              if (typeof window.__pdfAnnotAttachNodeBehaviors === 'function') {
                window.__pdfAnnotAttachNodeBehaviors(node);
              }
            } catch (_) {}
          };

          for (let i = 0; i < arr.length; i++) {
            const it = arr[i] || {};
            const type = (it.type || '').toString();
            const page = parseInt(it.page || 1, 10) || 1;
            const x = Number(it.x || 0);
            const y = Number(it.y || 0);
            const wNorm = Number(it.w || 0);
            const hNorm = Number(it.h || 0);
            const ref = overlaysByPage[String(page)];
            if (!ref || !ref.wrapper || !ref.overlay) continue;
            const wrapper = ref.wrapper;
            const overlay = ref.overlay;

            if (type === 'draw') {
              try {
                const key = String(page);
                const strokes = Array.isArray(it.strokes) ? it.strokes : [];
                if (strokes.length) this._strokesByPage[key] = strokes;
              } catch (_) {}
              continue;
            }

            if (type === 'text') {
              const box = document.createElement('div');
              box.contentEditable = 'false';
              box.innerText = (it.text || '').toString();
              box.style.minWidth = '60px';
              box.style.minHeight = '22px';
              box.style.padding = '6px 8px';
              box.style.border = 'none';
              box.style.borderRadius = '4px';
              box.style.background = 'transparent';
              box.style.font = '14px Arial, sans-serif';
              box.style.color = '#111';
              box.style.outline = 'none';
              box.style.userSelect = 'text';
              box.style.whiteSpace = 'pre-wrap';
              box.style.overflow = 'visible';
              box.style.boxSizing = 'border-box';
              box.setAttribute('data-annot-type', 'text');
              addNodeCommon(box, wrapper, overlay, page, x, y, wNorm, hNorm);
              continue;
            }

            if (type === 'signature') {
              const img = document.createElement('img');
              const src = (it.src || '').toString();
              img.src = src;
              img.style.width = '180px';
              img.style.height = 'auto';
              img.style.border = '2px solid rgba(26,115,232,0.9)';
              img.style.borderRadius = '6px';
              img.style.background = 'rgba(255,255,255,0.92)';
              img.style.padding = '4px';
              img.setAttribute('data-annot-type', 'signature');
              img.setAttribute('data-src', src);
              addNodeCommon(img, wrapper, overlay, page, x, y, wNorm, hNorm);
              continue;
            }
          }

          this._requestRedraw();
          return true;
        } catch (_) {
          return false;
        }
      },

    };

    window.pdfAnnot = pdfAnnot;

    // Restore saved signature (browser-local) so clients don't have to re-sign each proposal.
    try {
      const saved = pdfAnnot.getSavedSignatureDataUrl();
      if (saved && saved.trim()) pdfAnnot.signatureDataUrl = saved;
    } catch (_) {}

    // Global shortcuts:
    // - Esc: select mode (clear tool)
    // - Ctrl/Cmd+Z: undo draw on last active page
    // - Ctrl/Cmd+Y or Ctrl/Cmd+Shift+Z: redo
    window.__pdfAnnotActivePage = 1;
    window.addEventListener('keydown', (e) => {
      try {
        const key = (e.key || '').toLowerCase();
        const isMac = /mac|iphone|ipad|ipod/i.test(navigator.platform || '');
        const mod = isMac ? e.metaKey : e.ctrlKey;

        // If the user is typing in an input/textarea/contentEditable (e.g. text annotation),
        // let the browser handle native undo/redo.
        try {
          const ae = document.activeElement;
          const tag = (ae && ae.tagName ? String(ae.tagName).toUpperCase() : '');
          const isEditable = !!(ae && (ae.isContentEditable || tag === 'INPUT' || tag === 'TEXTAREA'));
          if (isEditable) return;
        } catch (_) {}

        if (!mod) return;
        const containerId = (window.__pdfAnnotActiveContainerId || '').toString();
        if (key === 'z' && !e.shiftKey) {
          e.preventDefault();
          if (typeof pdfAnnot.undoGlobal === 'function') {
            pdfAnnot.undoGlobal(containerId);
          }
          return;
        }
        if ((key === 'y') || (key === 'z' && e.shiftKey)) {
          e.preventDefault();
          if (typeof pdfAnnot.redoGlobal === 'function') {
            pdfAnnot.redoGlobal(containerId);
          }
          return;
        }
      } catch (_) {}
    });

    function clamp01(v) {
      if (v < 0) return 0;
      if (v > 1) return 1;
      return v;
    }

    function setSelected(node, selected) {
      if (!node) return;
      if (selected) {
        node.setAttribute('data-selected', '1');
        node.style.outline = '1px dashed rgba(26,115,232,0.85)';
        node.style.outlineOffset = '2px';
        const handles = node.querySelectorAll('[data-resize-handle="1"]');
        handles.forEach((h) => { h.style.display = 'block'; });
      } else {
        node.removeAttribute('data-selected');
        node.style.outline = 'none';
        node.style.outlineOffset = '0';
        const handles = node.querySelectorAll('[data-resize-handle="1"]');
        handles.forEach((h) => { h.style.display = 'none'; });
      }
    }

    function clearSelection(containerEl) {
      try {
        const nodes = containerEl.querySelectorAll('[data-annot-item="1"][data-selected="1"]');
        nodes.forEach((n) => setSelected(n, false));
      } catch (_) {}
    }

    function setOverlayCursor(overlayEl, tool) {
      try {
        const t = tool || null;
        if (t === 'draw') {
          overlayEl.style.cursor = 'crosshair';
        } else if (t === 'text') {
          overlayEl.style.cursor = 'text';
        } else if (t === 'signature') {
          overlayEl.style.cursor = 'crosshair';
        } else {
          overlayEl.style.cursor = 'default';
        }
      } catch (_) {}
    }

    function redrawInk(inkCanvas, wrapper, pageNum) {
      try {
        const ctx = inkCanvas.getContext('2d');
        if (!ctx) return;
        ctx.clearRect(0, 0, inkCanvas.width, inkCanvas.height);
        const key = String(pageNum || 1);
        const strokes = (pdfAnnot._strokesByPage && pdfAnnot._strokesByPage[key]) || [];
        const rect = { width: inkCanvas.width, height: inkCanvas.height };
        for (let i = 0; i < strokes.length; i++) {
          drawStrokePath(ctx, rect, strokes[i]);
        }
      } catch (_) {}
    }

    function drawStrokePath(ctx, rect, stroke) {
      const pts = (stroke && stroke.points) || [];
      if (!pts.length) return;
      ctx.save();
      ctx.strokeStyle = stroke.color || '#111111';
      ctx.lineWidth = typeof stroke.width === 'number' ? stroke.width : 2.0;
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      ctx.beginPath();
      for (let i = 0; i < pts.length; i++) {
        const p = pts[i];
        const x = (p.x || 0) * rect.width;
        const y = (p.y || 0) * rect.height;
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.stroke();
      ctx.restore();
    }

    function makeDraggable(node, wrapper, overlay) {
      let dragging = false;
      let startX = 0;
      let startY = 0;
      let origLeft = 0;
      let origTop = 0;
      let before = null;

      node.style.touchAction = 'none';

      node.addEventListener('pointerdown', (e) => {
        // If a tool is active, do not start dragging; tool handler owns pointer.
        // When no tool is active, allow dragging selected annotations.
        try {
          const t = pdfAnnot.tool;
          if (t && t !== 'text' && t !== 'signature') return;
        } catch (_) {}
        // If text is actively focused for typing, don't start drag.
        // (Otherwise the tool feels "stuck" and can't be moved.)
        try {
          const isEditing = node.getAttribute('data-editing') === '1';
          const isFocused = document.activeElement === node;
          if (isEditing && isFocused) return;
        } catch (_) {}
        e.preventDefault();
        e.stopPropagation();
        dragging = true;
        node.setPointerCapture(e.pointerId);
        startX = e.clientX;

        startY = e.clientY;
        origLeft = parseFloat(node.style.left || '0');
        origTop = parseFloat(node.style.top || '0');
        try {
          before = {
            left: origLeft,
            top: origTop,
            width: node.getBoundingClientRect().width,
            height: node.getBoundingClientRect().height,
            x: parseFloat(node.getAttribute('data-x') || '0'),
            y: parseFloat(node.getAttribute('data-y') || '0'),
            w: parseFloat(node.getAttribute('data-w') || '0'),
            h: parseFloat(node.getAttribute('data-h') || '0'),
          };
        } catch (_) {
          before = null;
        }
      });

      node.addEventListener('pointermove', (e) => {
        if (!dragging) return;
        const dx = e.clientX - startX;
        const dy = e.clientY - startY;
        const newLeft = origLeft + dx;
        const newTop = origTop + dy;
        node.style.left = newLeft + 'px';
        node.style.top = newTop + 'px';

        const wrapRect = wrapper.getBoundingClientRect();
        const box = node.getBoundingClientRect();
        const w = wrapRect.width;
        const h = wrapRect.height;
        const x = clamp01((box.left - wrapRect.left) / w);
        const y = clamp01((box.top - wrapRect.top) / h);
        const ww = clamp01(box.width / w);
        const hh = clamp01(box.height / h);
        node.setAttribute('data-x', String(x));
        node.setAttribute('data-y', String(y));
        node.setAttribute('data-w', String(ww));
        node.setAttribute('data-h', String(hh));
      });

      node.addEventListener('pointerup', (e) => {
        dragging = false;
        try { node.releasePointerCapture(e.pointerId); } catch (_) {}
        try {
          const id = node.getAttribute('data-annot-id');
          if (!id || !before) return;
          const after = {
            left: parseFloat(node.style.left || '0'),
            top: parseFloat(node.style.top || '0'),
            width: node.getBoundingClientRect().width,
            height: node.getBoundingClientRect().height,
            x: parseFloat(node.getAttribute('data-x') || '0'),
            y: parseFloat(node.getAttribute('data-y') || '0'),
            w: parseFloat(node.getAttribute('data-w') || '0'),
            h: parseFloat(node.getAttribute('data-h') || '0'),
          };
          if (Math.abs((after.left || 0) - (before.left || 0)) + Math.abs((after.top || 0) - (before.top || 0)) > 0.5) {
            pdfAnnot._pushHistory({ type: 'node_transform', id, before, after });
          }
        } catch (_) {}
      });

      node.addEventListener('pointercancel', () => {
        dragging = false;
      });
    }

    function makeResizable(node, wrapper) {
      const handle = document.createElement('div');
      handle.setAttribute('data-resize-handle', '1');
      handle.style.position = 'absolute';
      handle.style.right = '-6px';
      handle.style.bottom = '-6px';
      handle.style.width = '12px';
      handle.style.height = '12px';
      handle.style.borderRadius = '3px';
      handle.style.background = 'rgba(26,115,232,0.95)';
      handle.style.cursor = 'nwse-resize';
      handle.style.boxShadow = '0 1px 4px rgba(0,0,0,0.18)';
      handle.style.touchAction = 'none';
      handle.style.display = 'none';

      node.appendChild(handle);

      let resizing = false;
      let startX = 0;
      let startY = 0;
      let startW = 0;
      let startH = 0;
      let before = null;

      handle.addEventListener('pointerdown', (e) => {
        try {
          const t = pdfAnnot.tool;
          if (t && t !== 'text' && t !== 'signature') return;
        } catch (_) {}
        e.preventDefault();
        e.stopPropagation();
        resizing = true;
        handle.setPointerCapture(e.pointerId);
        startX = e.clientX;
        startY = e.clientY;
        const rect = node.getBoundingClientRect();
        startW = rect.width;
        startH = rect.height;
        try {
          before = {
            left: parseFloat(node.style.left || '0'),
            top: parseFloat(node.style.top || '0'),
            width: rect.width,
            height: rect.height,
            x: parseFloat(node.getAttribute('data-x') || '0'),
            y: parseFloat(node.getAttribute('data-y') || '0'),
            w: parseFloat(node.getAttribute('data-w') || '0'),
            h: parseFloat(node.getAttribute('data-h') || '0'),
          };
        } catch (_) {
          before = null;
        }
      });

      handle.addEventListener('pointermove', (e) => {
        if (!resizing) return;
        const dx = e.clientX - startX;
        const dy = e.clientY - startY;
        const newW = Math.max(40, startW + dx);
        const newH = Math.max(22, startH + dy);
        node.style.width = newW + 'px';
        node.style.height = newH + 'px';

        const wrapRect = wrapper.getBoundingClientRect();
        const box = node.getBoundingClientRect();
        const w = wrapRect.width;
        const h = wrapRect.height;
        const ww = clamp01(box.width / w);
        const hh = clamp01(box.height / h);
        node.setAttribute('data-w', String(ww));
        node.setAttribute('data-h', String(hh));
      });

      handle.addEventListener('pointerup', (e) => {
        resizing = false;
        try { handle.releasePointerCapture(e.pointerId); } catch (_) {}
        try {
          const id = node.getAttribute('data-annot-id');
          if (!id || !before) return;
          const rect = node.getBoundingClientRect();
          const after = {
            left: parseFloat(node.style.left || '0'),
            top: parseFloat(node.style.top || '0'),
            width: rect.width,
            height: rect.height,
            x: parseFloat(node.getAttribute('data-x') || '0'),
            y: parseFloat(node.getAttribute('data-y') || '0'),
            w: parseFloat(node.getAttribute('data-w') || '0'),
            h: parseFloat(node.getAttribute('data-h') || '0'),
          };
          if (Math.abs((after.width || 0) - (before.width || 0)) + Math.abs((after.height || 0) - (before.height || 0)) > 0.5) {
            pdfAnnot._pushHistory({ type: 'node_transform', id, before, after });
          }
        } catch (_) {}
      });

      handle.addEventListener('pointercancel', () => {
        resizing = false;
      });
    }

    function makeCornerResize(node, wrapper) {
      const handle = document.createElement('div');
      handle.setAttribute('data-resize-handle', '1');
      handle.style.position = 'absolute';
      handle.style.left = '-6px';
      handle.style.top = '-6px';
      handle.style.width = '12px';
      handle.style.height = '12px';
      handle.style.borderRadius = '3px';
      handle.style.background = 'rgba(26,115,232,0.95)';
      handle.style.cursor = 'nwse-resize';
      handle.style.boxShadow = '0 1px 4px rgba(0,0,0,0.18)';
      handle.style.touchAction = 'none';
      handle.style.display = 'none';

      node.appendChild(handle);

      let resizing = false;
      let startX = 0;
      let startY = 0;
      let startW = 0;
      let startH = 0;
      let startL = 0;
      let startT = 0;
      let before = null;

      handle.addEventListener('pointerdown', (e) => {
        try {
          const t = pdfAnnot.tool;
          if (t && t !== 'text' && t !== 'signature') return;
        } catch (_) {}
        e.preventDefault();
        e.stopPropagation();
        resizing = true;
        handle.setPointerCapture(e.pointerId);
        startX = e.clientX;
        startY = e.clientY;
        const rect = node.getBoundingClientRect();
        startW = rect.width;
        startH = rect.height;
        startL = parseFloat(node.style.left || '0');
        startT = parseFloat(node.style.top || '0');
        try {
          before = {
            left: startL,
            top: startT,
            width: rect.width,
            height: rect.height,
            x: parseFloat(node.getAttribute('data-x') || '0'),
            y: parseFloat(node.getAttribute('data-y') || '0'),
            w: parseFloat(node.getAttribute('data-w') || '0'),
            h: parseFloat(node.getAttribute('data-h') || '0'),
          };
        } catch (_) {
          before = null;
        }
      });

      handle.addEventListener('pointermove', (e) => {
        if (!resizing) return;
        const dx = e.clientX - startX;
        const dy = e.clientY - startY;
        const newW = Math.max(40, startW - dx);
        const newH = Math.max(22, startH - dy);
        node.style.width = newW + 'px';
        node.style.height = newH + 'px';
        node.style.left = (startL + dx) + 'px';
        node.style.top = (startT + dy) + 'px';

        const wrapRect = wrapper.getBoundingClientRect();
        const box = node.getBoundingClientRect();
        const w = wrapRect.width;
        const h = wrapRect.height;
        const x = clamp01((box.left - wrapRect.left) / w);
        const y = clamp01((box.top - wrapRect.top) / h);
        const ww = clamp01(box.width / w);
        const hh = clamp01(box.height / h);
        node.setAttribute('data-x', String(x));
        node.setAttribute('data-y', String(y));
        node.setAttribute('data-w', String(ww));
        node.setAttribute('data-h', String(hh));
      });

      handle.addEventListener('pointerup', (e) => {
        resizing = false;
        try { handle.releasePointerCapture(e.pointerId); } catch (_) {}
        try {
          const id = node.getAttribute('data-annot-id');
          if (!id || !before) return;
          const rect = node.getBoundingClientRect();
          const after = {
            left: parseFloat(node.style.left || '0'),
            top: parseFloat(node.style.top || '0'),
            width: rect.width,
            height: rect.height,
            x: parseFloat(node.getAttribute('data-x') || '0'),
            y: parseFloat(node.getAttribute('data-y') || '0'),
            w: parseFloat(node.getAttribute('data-w') || '0'),
            h: parseFloat(node.getAttribute('data-h') || '0'),
          };
          if (Math.abs((after.left || 0) - (before.left || 0)) + Math.abs((after.top || 0) - (before.top || 0)) > 0.5) {
            pdfAnnot._pushHistory({ type: 'node_transform', id, before, after });
          }
        } catch (_) {}
      });

      handle.addEventListener('pointercancel', () => {
        resizing = false;
      });
    }

    window.renderPdfInto = async function(containerId, url, opts) {
      try {
        try { console.log('[pdfjs] render_start', { containerId, url }); } catch (_) {}
        try { window.__pdfAnnotActiveContainerId = containerId; } catch (_) {}
        try {
          if (!window.__pdfRenderTokens) window.__pdfRenderTokens = {};
          const nextToken = (window.__pdfRenderTokens[String(containerId)] || 0) + 1;
          window.__pdfRenderTokens[String(containerId)] = nextToken;
        } catch (_) {}
        let el = document.getElementById(containerId);

        // Flutter web can occasionally leave multiple DOM nodes with the same id
        // when platform views are rebuilt. That results in the PDF appearing twice.
        // Keep the most recent node and remove older duplicates.
        try {
          const all = document.querySelectorAll('[id="' + String(containerId) + '"]');
          if (all && all.length > 1) {
            for (let i = 0; i < all.length - 1; i++) {
              const n = all[i];
              try { n.innerHTML = ''; } catch (_) {}
              try {
                if (n.parentNode) n.parentNode.removeChild(n);
              } catch (_) {}
            }
            el = all[all.length - 1];
          } else if (all && all.length === 1) {
            el = all[0];
          }
        } catch (_) {}

        if (!el) {
          // Flutter platform views may create the element before it is attached to
          // document. Wait briefly for DOM attachment.
          for (let i = 0; i < 40 && !el; i++) {
            await new Promise((r) => setTimeout(r, 25));
            el = document.getElementById(containerId);
          }
        }
        if (!el) {
          throw new Error('pdf_container_not_found:' + containerId);
        }

        let myToken = null;
        try { myToken = window.__pdfRenderTokens ? window.__pdfRenderTokens[String(containerId)] : null; } catch (_) {}
        try {
          if (myToken != null) el.setAttribute('data-pdf-render-token', String(myToken));
        } catch (_) {}

        const options = opts || {};
        const scale = typeof options.scale === 'number' ? options.scale : 1.2;

        try {
          if (typeof el.replaceChildren === 'function') {
            el.replaceChildren();
          } else {
            el.innerHTML = '';
          }
        } catch (_) {
          el.innerHTML = '';
        }
        el.style.background = '#f5f7f9';

        const pdfjs = await __ensurePdfJsLoaded();
        const getDocument = pdfjs.getDocument;

        // If a newer render started while we were awaiting pdf.js load, abort.
        try {
          const cur = window.__pdfRenderTokens ? window.__pdfRenderTokens[String(containerId)] : null;
          if (myToken != null && cur != null && myToken !== cur) return;
        } catch (_) {}

        // Reliability: disable range/streaming fetch. In some environments (auth tokens,
        // proxies, CORS), partial-content requests can yield blank renders.
        const loadingTask = getDocument({
          url,
          disableRange: true,
          disableStream: true,
          disableAutoFetch: true,
        });

        const pdf = await loadingTask.promise;

        // If a newer render started while we were loading the PDF, abort.
        try {
          const cur = window.__pdfRenderTokens ? window.__pdfRenderTokens[String(containerId)] : null;
          if (myToken != null && cur != null && myToken !== cur) {
            try { loadingTask.destroy(); } catch (_) {}
            return;
          }
        } catch (_) {}

        for (let pageNum = 1; pageNum <= pdf.numPages; pageNum++) {
          // Abort mid-render if a newer render started.
          try {
            const cur = window.__pdfRenderTokens ? window.__pdfRenderTokens[String(containerId)] : null;
            if (myToken != null && cur != null && myToken !== cur) {
              try { loadingTask.destroy(); } catch (_) {}
              return;
            }
          } catch (_) {}
          const page = await pdf.getPage(pageNum);
          const viewport = page.getViewport({ scale });

          // Extra guard: if the container was reused/re-rendered, do not append.
          try {
            const elTok = el.getAttribute('data-pdf-render-token');
            if (myToken != null && elTok != null && String(myToken) !== String(elTok)) {
              try { loadingTask.destroy(); } catch (_) {}
              return;
            }
          } catch (_) {}

          const wrapper = document.createElement('div');
          wrapper.style.position = 'relative';
          wrapper.style.width = viewport.width + 'px';
          wrapper.style.height = viewport.height + 'px';
          wrapper.style.margin = '0 auto 14px auto';
          wrapper.style.boxShadow = '0 2px 10px rgba(0,0,0,0.08)';
          wrapper.style.background = '#fff';
          wrapper.setAttribute('data-page', String(pageNum));

          const canvas = document.createElement('canvas');
          canvas.width = viewport.width;
          canvas.height = viewport.height;
          canvas.style.display = 'block';
          canvas.style.width = '100%';
          canvas.style.height = '100%';

          const inkCanvas = document.createElement('canvas');
          inkCanvas.width = viewport.width;
          inkCanvas.height = viewport.height;
          inkCanvas.style.position = 'absolute';
          inkCanvas.style.left = '0';
          inkCanvas.style.top = '0';
          inkCanvas.style.width = '100%';
          inkCanvas.style.height = '100%';
          inkCanvas.style.pointerEvents = 'none';

          const overlay = document.createElement('div');
          overlay.style.position = 'absolute';
          overlay.style.left = '0';
          overlay.style.top = '0';
          overlay.style.right = '0';
          overlay.style.bottom = '0';
          setOverlayCursor(overlay, pdfAnnot.tool);

          wrapper.appendChild(canvas);
          wrapper.appendChild(inkCanvas);
          wrapper.appendChild(overlay);
          el.appendChild(wrapper);

          // Keep active page updated for keyboard undo/redo.
          try {
            overlay.addEventListener('pointerdown', () => { window.__pdfAnnotActivePage = pageNum; });
            wrapper.addEventListener('pointerdown', () => { window.__pdfAnnotActivePage = pageNum; });
          } catch (_) {}

          // Keep cursor in sync with current tool.
          try {
            const onTool = (ev) => {
              try {
                const e = ev;
                const d = e && e.detail;
                const nextTool = d && (d.tool === undefined ? null : d.tool);
                setOverlayCursor(overlay, nextTool);
              } catch (_) {
                setOverlayCursor(overlay, pdfAnnot.tool);
              }
            };
            window.addEventListener('pdf_annot_tool_changed', onTool);
          } catch (_) {}

          // Ensure undo/redo triggers a visible re-render.
          try {
            pdfAnnot.onRedraw(() => {
              try { redrawInk(inkCanvas, wrapper, pageNum); } catch (_) {}
            });
          } catch (_) {}

          let drawing = false;
          let currentStroke = null;

          overlay.style.touchAction = 'none';

          overlay.addEventListener('pointerdown', (e) => {
            const t = pdfAnnot.tool;
            try { window.__pdfAnnotActivePage = pageNum; } catch (_) {}
            // If clicking an existing annotation, don't create a new one.
            try {
              let n = e.target;
              while (n && n !== overlay) {
                if (n.getAttribute && n.getAttribute('data-annot-item') === '1') {
                  e.stopPropagation();
                  clearSelection(el);
                  setSelected(n, true);
                  return;
                }
                n = n.parentNode;
              }
            } catch (_) {}
            if (!t) {
              // Selection mode
              clearSelection(el);
              return;
            }

            const rect = wrapper.getBoundingClientRect();

            const xPx = e.clientX - rect.left;
            const yPx = e.clientY - rect.top;
            const x = clamp01(xPx / rect.width);
            const y = clamp01(yPx / rect.height);
            const page = parseInt(wrapper.getAttribute('data-page') || '1', 10);

            if (t === 'draw') {
              e.preventDefault();
              e.stopPropagation();
              drawing = true;
              overlay.setPointerCapture(e.pointerId);
              currentStroke = {
                color: pdfAnnot.strokeColor || '#111111',
                width: typeof pdfAnnot.strokeWidth === 'number' ? pdfAnnot.strokeWidth : 2.0,
                points: [{ x, y }],
              };

              const key = String(page);
              if (!pdfAnnot._strokesByPage[key]) pdfAnnot._strokesByPage[key] = [];
              pdfAnnot._strokesByPage[key].push(currentStroke);
              // New stroke invalidates redo stack.
              try { pdfAnnot._undoneStrokesByPage[key] = []; } catch (_) {}
              try { pdfAnnot._pushHistory({ type: 'draw_add', page, stroke: currentStroke }); } catch (_) {}
              return;
            }

            if (t === 'text') {
              const box = document.createElement('div');

              box.contentEditable = 'true';
              box.innerText = 'Text';

              box.style.position = 'absolute';
              box.style.left = (xPx) + 'px';
              box.style.top = (yPx) + 'px';
              box.style.minWidth = '60px';
              box.style.minHeight = '22px';
              box.style.padding = '6px 8px';
              box.style.border = '1px dashed rgba(26,115,232,0.9)';
              box.style.borderRadius = '4px';
              box.style.background = 'rgba(255,255,255,0.20)';
              box.style.font = '14px Arial, sans-serif';
              box.style.color = '#111';
              box.style.outline = 'none';
              box.style.userSelect = 'text';
              box.style.whiteSpace = 'pre-wrap';
              // Allow resize handles to be visible/clickable.
              box.style.overflow = 'visible';
              box.style.boxSizing = 'border-box';

              box.setAttribute('data-annot-item', '1');
              box.setAttribute('data-annot-type', 'text');
              const annotId = String(pdfAnnot._nextAnnotId++);
              box.setAttribute('data-annot-id', annotId);
              box.setAttribute('data-page', String(page));
              box.setAttribute('data-x', String(x));
              box.setAttribute('data-y', String(y));
              box.setAttribute('data-w', String(0.12));
              box.setAttribute('data-h', String(0.04));

              overlay.appendChild(box);
              makeDraggable(box, wrapper, overlay);
              makeResizable(box, wrapper);
              makeCornerResize(box, wrapper);
              try { pdfAnnot._pushHistory({ type: 'node_create', id: annotId, page, html: box.outerHTML }); } catch (_) {}

              box.addEventListener('pointerdown', (ev) => {
                try { window.__pdfAnnotActivePage = pageNum; } catch (_) {}
                ev.stopPropagation();
                clearSelection(el);
                setSelected(box, true);
              });

              box.addEventListener('dblclick', (ev) => {
                ev.preventDefault();
                ev.stopPropagation();
                clearSelection(el);
                setSelected(box, true);
                box.setAttribute('data-editing', '1');
                box.contentEditable = 'true';
                box.style.border = '1px dashed rgba(26,115,232,0.9)';
                box.style.background = 'rgba(255,255,255,0.20)';
                setTimeout(() => { try { box.focus(); } catch (_) {} }, 0);
              });

              box.addEventListener('blur', () => {
                box.removeAttribute('data-editing');
                box.contentEditable = 'false';
                box.style.border = 'none';
                box.style.background = 'transparent';
                box.style.overflow = 'visible';
              });

              // Initial edit
              clearSelection(el);
              setSelected(box, true);
              box.setAttribute('data-editing', '1');
              setTimeout(() => { try { box.focus(); } catch (_) {} }, 0);
            }

            if (t === 'signature') {
              const src = pdfAnnot.signatureDataUrl;
              if (!src) return;
              const img = document.createElement('img');
              img.src = src;

              img.style.position = 'absolute';
              img.style.left = (xPx) + 'px';
              img.style.top = (yPx) + 'px';
              img.style.width = Math.max(140, rect.width * 0.22) + 'px';
              img.style.height = 'auto';
              img.style.border = '2px solid rgba(26,115,232,0.9)';
              img.style.borderRadius = '6px';
              img.style.background = 'rgba(255,255,255,0.92)';
              img.style.padding = '4px';

              img.setAttribute('data-annot-item', '1');
              img.setAttribute('data-annot-type', 'signature');
              const annotId = String(pdfAnnot._nextAnnotId++);
              img.setAttribute('data-annot-id', annotId);
              img.setAttribute('data-src', src);
              img.setAttribute('data-page', String(page));
              img.setAttribute('data-x', String(x));
              img.setAttribute('data-y', String(y));
              img.setAttribute('data-w', String(0.22));
              img.setAttribute('data-h', String(0.08));

              overlay.appendChild(img);
              makeDraggable(img, wrapper, overlay);
              makeResizable(img, wrapper);
              makeCornerResize(img, wrapper);
              try { pdfAnnot._pushHistory({ type: 'node_create', id: annotId, page, html: img.outerHTML }); } catch (_) {}
              img.addEventListener('pointerdown', (ev) => {
                try {
                  if (pdfAnnot.tool) return;
                } catch (_) {}
                ev.stopPropagation();
                clearSelection(el);
                setSelected(img, true);
              });

              clearSelection(el);
              setSelected(img, true);
            }
          });

          overlay.addEventListener('pointermove', (e) => {
            if (!drawing) return;
            if (pdfAnnot.tool !== 'draw') return;
            const rect = wrapper.getBoundingClientRect();
            const x = clamp01((e.clientX - rect.left) / rect.width);
            const y = clamp01((e.clientY - rect.top) / rect.height);

            if (currentStroke && currentStroke.points) {
              const pts = currentStroke.points;
              const last = pts.length ? pts[pts.length - 1] : null;
              // Stabilize: reduce point spam + jitter.
              if (!last || Math.abs(last.x - x) + Math.abs(last.y - y) > 0.004) {
                pts.push({ x, y });
              }
            }
            redrawInk(inkCanvas, wrapper, pageNum);
          });

          overlay.addEventListener('pointerup', (e) => {
            if (!drawing) return;
            drawing = false;
            currentStroke = null;
            try { overlay.releasePointerCapture(e.pointerId); } catch (_) {}
          });

          overlay.addEventListener('pointercancel', () => {
            drawing = false;
            currentStroke = null;
          });

          const ctx = canvas.getContext('2d', { alpha: false });
          await page.render({ canvasContext: ctx, viewport }).promise;
          // Paint any existing strokes after render (e.g. after zoom / rerender).
          redrawInk(inkCanvas, wrapper, pageNum);
        }

        if (!el.firstChild) {
          throw new Error('pdf_rendered_no_dom_nodes');
        }
        try {
          const canvases = el.querySelectorAll('canvas').length;
          console.log('[pdfjs] render_ok', { containerId, pages: pdf.numPages, canvases });
        } catch (_) {}
        return true;
      } catch (err) {
        try { console.error('[pdfjs] renderPdfInto failed', err); } catch (_) {}
        try { window.__lastPdfJsError = String(err && (err.message || err) || err); } catch (_) {}
        throw err;
      }
    };

  </script>
</head>

<body>
  <script>
    // Force HTML renderer so platform views (HtmlElementView) are visible.
    // This is required on some Flutter versions where CanvasKit can blank out
    // embedded DOM elements, and where the CLI flag --web-renderer isn't available.
    window.flutterWebRenderer = "html";
  </script>
  <script src='flutter_bootstrap.js' async></script>
</body>
</html>